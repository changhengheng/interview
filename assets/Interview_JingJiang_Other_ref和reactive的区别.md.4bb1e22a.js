import{_ as e,o as r,c as t,O as i}from"./chunks/framework.3d6e08ae.js";const p=JSON.parse('{"title":"ref 和 reactive 的区别","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/JingJiang/Other/ref和reactive的区别.md","filePath":"Interview/JingJiang/Other/ref和reactive的区别.md"}'),a={name:"Interview/JingJiang/Other/ref和reactive的区别.md"},c=i('<h1 id="ref-和-reactive-的区别" tabindex="-1">ref 和 reactive 的区别 <a class="header-anchor" href="#ref-和-reactive-的区别" aria-label="Permalink to &quot;ref 和 reactive 的区别&quot;">​</a></h1><ul><li>ref 可以用来定义基本类型和引用类型数据；reactive 只能用来定义引用类型数据（可以传基本值，但是会失去响应式）；</li><li>ref 定义的数据如果是引用数据类型，实际是通过 reactive 来定义的。</li><li>ref 定义的数据需要通过 .value 来读取或更新，reactive 可以直接操作数据；</li><li>reactive 创建的代理对象的属性解构出来就不是响应式了；但如果一个对象的属性是 ref ，那么即使该属性是被解构出来使用，ref 也可以保证 .value 属性永远是响应式的；</li><li>ref 操作对象的时候，可以通过 .value 修改整个对象，依然是响应式；reactive 操作对象的时候，不能整体修改对象，修改了就不是响应式数据了；</li><li>watch 监视 reactive 默认开启深度监视，监视 ref 不会开启深度监视；</li><li>基本类型数据的原理是 Object.defineProperty，引用数据类型的原理是 Proxy/Reflect</li></ul><ul><li>修改 proxy 对象的值，会影响源对象；修改 ref 基本值的值不会影响源基本值，修改 ref 对象类型值的值会影响源对象（本质上还是proxy）；</li></ul>',3),l=[c];function n(_,o,f,s,v,d){return r(),t("div",null,l)}const u=e(a,[["render",n]]);export{p as __pageData,u as default};
