import{_ as e,o as i,c as t,U as o}from"./chunks/framework.e0394e94.js";const u=JSON.parse('{"title":"为什么不推荐 v-for 与 v-if 一起使用","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/JingJiang/Vue/基础/为什么不推荐v-for与v-if一起使用.md","filePath":"Interview/JingJiang/Vue/基础/为什么不推荐v-for与v-if一起使用.md","lastUpdated":1689411224000}'),r={name:"Interview/JingJiang/Vue/基础/为什么不推荐v-for与v-if一起使用.md"},a=o('<h1 id="为什么不推荐-v-for-与-v-if-一起使用" tabindex="-1">为什么不推荐 v-for 与 v-if 一起使用 <a class="header-anchor" href="#为什么不推荐-v-for-与-v-if-一起使用" aria-label="Permalink to &quot;为什么不推荐 v-for 与 v-if 一起使用&quot;">​</a></h1><p>一起使用是指 <strong>在同一个标签上使用</strong>。</p><p>Vue3 中 v-if 优先级高于 v-for 优先级，不存在什么问题；Vue2 中，v-for 优先级高于 v-if 优先级，因此会先遍历完再判断是否渲染元素，这样会造成不必要的消耗——不需要渲染的根本不需要遍历；</p><p>两种解决方法：</p><p>看 v-if <strong>用来判断的数据</strong>与 v-for <strong>遍历的数据</strong> 是否有关联</p><p>有关联：即判断使用 v-for 遍历的数据</p><ul><li>问题: 如果使用 v-if，每个数组元素都会解析指令来判断，效率低</li><li>解决：使用 computed 计算属性过滤产生一个子数组，不使用 v-if，效率比较高</li></ul><p>没关联：即判断使用外部的数据</p><ul><li>问题: 如果在当前标签上用 v-if，执行 n 次，效率低</li><li>解决: 添加一个父标签使用 v-if，内层使用 v-for 遍历，执行 1 次，效率高</li></ul>',9),f=[a];function _(n,v,s,l,p,c){return i(),t("div",null,f)}const g=e(r,[["render",_]]);export{u as __pageData,g as default};
