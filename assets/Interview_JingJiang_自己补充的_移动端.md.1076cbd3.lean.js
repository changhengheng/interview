import{_ as e,o as t,c as i,z as n}from"./chunks/framework.3d6e08ae.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/JingJiang/自己补充的/移动端.md","filePath":"Interview/JingJiang/自己补充的/移动端.md"}'),c={name:"Interview/JingJiang/自己补充的/移动端.md"},s=n("pre",null,[n("code",null,`# 移动端
1. 屏幕尺寸
所有的屏幕都是正方或者长方的
对角线的长度   英寸表示    1英寸 ≈ 2.54cm
屏幕是物理硬件设备，一旦出厂，就没法改变长度
2. 屏幕分辨率（iphone6  750*1334）
横纵向上像素点数的乘积（物理像素点）
分辨率描述的就是屏幕上总的像素点数（物理像素）
屏幕分辨率也是不能改的
3. 屏幕像素密度
单位英寸上所包含的物理像素点数
这个值求法： 与屏幕尺寸和屏幕分辨率关系密切      
通过分辨率和勾股定理可以求出对角线上总的像素点数
4. 物理像素 （物理硬件描述）
5. css像素 （用户描述）
抽象的   用来精确的度量web页面的尺寸大小的   给web开发人员使用
通常我们在css以及js当中所使用的都是css像素；
6. 设备独立像素   （系统描述，包含css像素）
设备独立像素是为了让物理像素更好的展现用户层的像素而出现的，是为了转化；
在某些特定的条件下，css像素可以  =  设备独立像素；
也是抽象的虚拟像素
iphone6：用物理像素去描述-750，用设备独立像素描述-375 
7. 像素比（dpr）
物理像素和设备独立像素之间的比例；（可以让设备独立像素和物理像素拉关系）
在没有任何的缩放情况下（完美）  设备的独立像素  ==   css像素的
普通屏： 不考虑任何的缩放      1css像素  = 1物理像素  = 1设备独立像素
高清屏  dpr = 2：                1          2	        1;dpr = 3                  1          3            1

iphone6用三种像素描述分别是多少
1、物理   750px
2、css    375px
3、设备   375px

8. 思考：
在不考虑任何缩放的前提下：（前提是它）
物理像素和css像素的关系是什么？
要根据dpr去计算

css像素和设备独立像素的关系是什么？
css像素  =  设备独立像素  

        
9.最终屏幕宽度在理想完美状态用各种像素的描述各是多少？

物理像素      750px
设备独立像素  375px
css像素       375px

10. pc视口
pc的视口的4种打印方式

11. 布局视口
为了转移pc的网页，而引入的一个容器。它的大小是要远大于设备独立像素，各个设备差异不大。（980）
为了把这个布局视口当中的元素全部展现给客户，并且不能出现横向滚动条。浏览器厂商会自作主张把布局视口，进行压缩（压缩的是css面积，css大小不会变化）
最终：我们的手机宽度此时用三种像素描述就变为了：
    
物理像素     750
设备独立像素 375
css像素      980	

12. 视觉视口
宽度永远是屏幕宽度所包含的css像素值，是变化的

    
13. 理想视口
meta  name = "viewport"  content = "width=device-width"
最终达到的目标    布局适口  = 视觉视口  = 理想视口 = 设备独立像素 = 375

width=device-width  width代表布局视口宽度  device-width代表的是设备独立像素值

14. 不写\`\` \`meta\` \`\`标签（不符合理想视口标准）
描述屏幕：物理像素：750px 、设备独立像素：375px、 css像素：980px。
优点：元素在不同设备上，呈现效果几乎一样，因都是通过布局容器等比缩放的，例如200宽的盒子：200/980
缺点：2
写\`\` \`meta\` \`\`标签（符合理想视口标准）：

描述屏幕：物理像素：750px 、设备独立像素：375px、  css像素：375px。
优点：页面清晰展现，内容不再小到难以观察，用户体验较好。
缺点：同一个元素，在不同屏幕（设备）上，呈现效果不一样，例如375宽的盒子： 375/375 和 375/414 (不是等比显示)
如何解决：做适配。

15. pc缩放
布局
    布局发生改变，因为初始包含块在发生改变，视口在发生改变，很少用
    
元素  
    元素的css像素值不会发生改变，但是CSS的面积发生改变

元素所占的物理像素
    因为元素的面积变大，所以元素占据的物理像素点变多

16. 移动端的用户缩放

17. 放大有什么变化
布局   				不变    布局视口大小不会发生改变
元素   				面积变大   css像素值不变
元素占用物理像素   		变多
视觉视口			        变小
视觉视口种的元素个数		变少

18. 缩小有什么变化
布局   				不变    布局视口大小不会发生改变
元素   				面积变小   css像素值不变
元素占用物理像素   		变少
视觉视口			        变大
视觉视口种的元素个数		变多

系统缩放

20. meta解决大元素兼容性问题和安卓系统的兼容性
meta标签同时协商  width = device-width 和 initial-scale=1.0	
initial-scale系统缩放比例 =  设备独立像素 / 布局视口宽度
        
21. 只设置initial-scale和只设置width效果一样

23. 同时initial-scale和width听谁的
如果同时设置，最终谁让我的布局视口更大，就听谁的；
一般如果值最终导致的布局视口是一样的，那么就一起写
如果两个值不一样，那么就只设置让布局视口大的就行

22. 系统缩放有什么不同 *********************
用户的缩放不会改变布局视口的大小
但是系统的缩放会改变布局视口的大小

系统缩放比例 =  设备独立像素 / 布局视口宽度
系统缩放比例值大于1 布局视口会变小
系统缩放比例值小于1 布局视口会变大

24. 最终我们以后用的meta标签要如何写
\`<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no,viewport-fit=cover " />\`
    
25.lengthmeta元素设置的所有属性

viewport 相关选项
1. width  布局视口的宽度
2. initial-scale  【系统】初始缩放比例
3. maximum-scale 允许【用户】缩放的最大比例
4. minimum-scale  允许【用户】缩放的最小比例
5. user-scalable  是否允许用户缩放
6. viewport-fit 设置为cover值可以解决刘海屏的留白问题 

1. width 
    width值可以是 device-width，也可以是具体值，但有些安卓手机是不支持具体值，IOS全系列都支持。</span>

2. initial-scale  

    1. initial-scale 为页面初始化时的显示比例。  
    2. initial-scale = 屏幕宽度(设备独立像素)  /  布局视口宽度。
    3. 只写initial-scale = 1.0 也可以实现完美视口，但为了良好的兼容性，width=device-width, initial-scale=1.0一般一起写。

3. maximum-scale 

    1. 设置允许用户最大缩放比例，苹果浏览器 safari 不认识该属性
    2. maximum-scale = 屏幕宽度(设备独立像素) / 视觉视口宽度值

4. minimum-scale

    1. 设置允许用户最小缩放比例。
    2. minimum-scale = 屏幕宽度(设备独立像素) / 视觉视口宽度值

5. user-scalable
    是否允许用户通过手指缩放页面。苹果浏览器 safari 不认识该属性

6.viewport-fit
    设置为 cover 可以解决『刘海屏』的留白问题




回顾：屏幕相关的知识  屏幕尺寸  分辨率  像素密度（dpi ppi）

        物理像素   css像素   设备独立像素  dpr


        在理想状态下他们三者的关系（普通屏、高清屏）
        普通屏   1   1   1
        高清屏   dpr (window.dpr)    2     2  1  1     width
                                        3     3  1  1     

        iphone6在理想状态下三种像素描述它的宽度分别是多少
        750   375   375




三种视口
布局视口  
视觉视口  
理想视口



pc端用户缩放    视口改变 



移动端用户缩放   
布局视口不会改变的
放大  css面积变大  视觉视口就变小   一个元素占用的物理像素变多了
缩小  css面积变小  视觉视口变大    一个元素占用的物理像素就变少了


系统缩放 
会导致布局视口发生改变
这个值如果是大于1  布局视口在变小
这个值如果是小于1  布局视口是在变大
initial-scale=1.0

设备独立像素 / 布局视口宽度


    最终我们要的meta标签的写法
    name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"
    width：width代表的是布局视口的宽度，我们在手动修改布局视口的宽度
    device-width：设备宽度，对应的是设备独立像素的值
    强制的把布局视口的宽度，设置为设备的设备独立像素值，把980 变为375
    为了把布局视口引入的时候打破的完美状态，再找回来
    后期要做移动端，第一件事就是考虑meta标签有没有写
    不写meta   布局永远是等比的  无论什么设备，布局视口都是980 ，但是体验不好
    写了meta   布局不等比（同样的设计稿在不同设备上显示效果不一样），不同的设备布局视口
                不一样，（设置的时候如果写绝对单位px），但是体验很好


    1、为什么要做适配
        因为同样的一个元素，在一个设备上和另外一个设备上显示的布局不同。也就是比例不一样。导致不同设备显示不成等比
        无论什么样的视口最终都是要等比显示 适配的关键

        适配其实就是为了不同设备等比显示

        想想为什么不成等比？


        375/980 在没有设置理想视口的时候都是等比的


        设置理想视口不等比就是因为这两个条件：
            1布局视口宽度不同（写了meta造成的）  
            2单位是一个绝对的
            width = device-width   布局视口根据设备不同 设置的宽度不同
            375px  又是一个固定的绝对的单位



    2、px em rem %单位的区别
        px     px是所有单位的祖宗   而且px是一个绝对的单位 
        %      是一个相对的单位，宽高在设置的时候相对的是父级元素。所以元素如果不多，可以使用；
        em     是一个相对的单位，单位相对的是自身的字体大小   1em = 自身的字体大小；			
        rem    也是一个相对的单位，相对的永远是根元素html的字体大小。默认情况下  1rem = 16px；
        vw     它是后期添加的一个相对单位  一般都是在移动端使用 1vw代表  百分之1屏幕的宽度
            100vw代表就是 整个屏幕的宽度



    3、rem适配
        搜狐、唯品会的移动端页面用的此方案
            （最终我们要做的动态的拿到布局视口宽度 / 10求出1rem的字体大小，设置给html即可）


            适配方法

                无论什么设备，无论什么设计稿  直接把设计稿宽度作为10rem
                设计稿宽度是10rem，那么设备这边宽度也得是10rem 才能等比
                我们只需要把设备宽度/10 作为根元素字体大小即可



            书写元素样式的方法
                设计稿看作是10rem，设计稿的宽度我们是知道的，这样可以求出设计稿的rem值为多少px
                在写样式的时候，设计稿上div标注的px/设计稿1rem的px值，就可以得到盒子在设计稿上占的rem值
                在手机这边布局的时候，直接写这个rem值即可得到等比



            ***************************************************************
            操作真实dom 会导致效率低下，原因是因为会引起dom树重新渲染
            dom树重新渲染：重排和重绘
            假设你改变了元素的位置和大小，那么这个渲染的过程就牵扯到重排
            这个重排的消耗是很大的

            假设你只是改了元素的颜色  背景色  字体颜色 那么这个渲染的过程牵扯到重绘
            比重排的消耗要小，效率要好

            频繁操作真实dom导致 
            一定会重绘，但是不一定重排
            如果重排了，那么就一定重绘



            唯品会适配方案： 
                优点：可以在计算设备的1rem字体的时候，直接除以10，比较简单
                缺点：我们在去计算元素在设计稿所占的rem值（后期要在设备上所写的rem值），
                    就比较麻烦，小数也比较多






        淘宝移动端页面用的方案
            适配方法：
                无论什么设备，无论什么设计稿  在设计稿上直接把100px作为1rem
                这样设计稿的总rem值我们是可以得到，然后可以把这个rem值作为设备总的宽度rem值
                我们只需要把设备宽度/得到的rem值 作为根元素字体大小即可


            书写元素样式的方法：
                在写样式的时候，设计稿设计值/100，即得到设备上该写的rem值

            
            淘宝的适配方案
                优点：设计稿这边100px做为1rem,后期求元素在设计稿这边的rem（就是我们要在设备上写的rem值）
                    就很好求，直接小数点往前走两位

                缺点：计算设备的1rem字体的时候，比较复杂，也可能出现很多小数



        

        rem适配以后用的很多
            没有破坏完美理想视口
            计算比较复杂 可以使用less 解决
            配合less去做

            如果是在脚手架创建的项目当中，less都不需要写，因为我们可以配loader和插件
            帮我们去计算



    4、函数封装
        修改屏幕 重新调用函数进行适配
























    5、viewport适配是什么，目的是什么

        前面我们的rem适配 都没有打破我们的理想视口，也就是布局视口宽度我们是不会动的

        viewport适配的目的是将我们的屏幕布局视口的宽度调整到和图稿宽度一致	
        这样的适配用的不多，因为破坏了完美理想视口

        想要改变布局视口的宽度，必须使用系统缩放，才能改变布局视口宽度
        注意：
            如果出现设计稿比手机屏幕还小，一般采用这个适配

            如果设计稿比手机屏幕大，一般我们使用的是rem适配，不是说不能用viewport适配
            而是使用的时候，元素会发生失真或者缩小的情况，体验不好

    
    6、viewport适配练习
        300图稿
        375 //动态求出的设备布局视口宽度
        计算initial-scale的值为多少，我们可以让屏幕宽度（布局视口）从375 变为 300

        
    
    7、1物理像素适配  
        1物理像素边框适配
        其它的东西比如宽高不变，只是想要一个1物理像素的边框

        媒体查询
        iphone6


        @media screen and (-webkit-min-device-pixel-ratio:2){
            #demo{
                border: 0.5px solid black;
            }
        }
        iphone6plus
        @media screen and (-webkit-min-device-pixel-ratio:3){
            #demo{
                border: 0.33333px solid black;
            }
        }

        或

        @media screen and (-webkit-min-device-pixel-ratio:2){
            #demo2::after{
                transform:scaleY(0.5);
            }
        }




    8、移动端事件
        手指按下  touchstart
        手指移动  touchmove
        手指离开  touchend
        事件对象  		
            浏览器在调用事件回调的时候会把这一次触发事件相关的所有信息封装为一个对象，传递给回调的第一个形参
        手指列表
            touches
            targetTouches
            changedTouches

        回调：1、自己定义的  2、自己没调用  3、最终执行了
        回调能最终执行，肯定是有人帮我们调，谁帮我们调，要看场景
        事件 ajax 定时器 这些回调都是浏览器帮我们调



    9、手指列表伪数组（移动端如何获取手指事件的位置）
        touches            屏幕上的手指列表

        targetTouches	   目标元素上的手指列表

        changedTouches	   目标元素目标事件上的手指列表	   
                        最终我们选择手指列表要的changedTouches
        
        






        
    10、点透（穿透）事件处理两大步

    touch 事件结束后会默认触发元素的 click 事件,如没有设置完美视口，则事件触发的时间间隔为 300ms 左右，如设置完美视口则时间间隔为 30ms 左右（备注：具体的时间也看设备的特性）。 如果 touch 事件隐藏了元素，则 click 动作将作用到新的元素上，触发新元素的 click 事件或a页面跳转，
    此现象称为点击穿透



    移动端最终工作和pc的区别：
        pc端开发和移动端开发其实差不多，只是移动端比pc端多了一些准备工作

        在开发前
            1、设置meta标签把视口拉为完美理想视口
            2、采取适合的适配方式进行适配（rem适配）





            

            3、之前pc端的事件切换为移动端的事件  click -> touchstart

            4、移动端事件注意点击穿透  处理a标签点击穿透的问题


        注意：后期我们在开发项目的时候用的都是工程化开发，环境当中已经把后面的两件事都处理了
        我们后期做工程化项目的时候，如果要写移动端只是比pc端多了个适配
`)],-1),a=[s];function r(m,d,p,o,l,h){return t(),i("div",null,a)}const x=e(c,[["render",r]]);export{v as __pageData,x as default};
