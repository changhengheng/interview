import{_ as s,o as a,c as l,U as n}from"./chunks/framework.e0394e94.js";const u=JSON.parse('{"title":"axios 二次封装（完整的 promise 的功能）","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/JingJiang/resume/axios二次封装/axios二次封装.md","filePath":"Interview/JingJiang/resume/axios二次封装/axios二次封装.md","lastUpdated":null}'),p={name:"Interview/JingJiang/resume/axios二次封装/axios二次封装.md"},e=n(`<h1 id="axios-二次封装-完整的-promise-的功能" tabindex="-1">axios 二次封装（完整的 promise 的功能） <a class="header-anchor" href="#axios-二次封装-完整的-promise-的功能" aria-label="Permalink to &quot;axios 二次封装（完整的 promise 的功能）&quot;">​</a></h1><p>实现功能一共 8 点</p><h2 id="基本" tabindex="-1">基本： <a class="header-anchor" href="#基本" aria-label="Permalink to &quot;基本：&quot;">​</a></h2><ol><li>配置统一的请求基础路径（前缀 baseUrl）和超时限制（timeOut）</li><li>添加进度条功能（NProgress）（也可以在路由守卫去做）</li><li>返回响应 Response 里的 data，而不是返回响应 Response</li><li>统一处理错误 <ul><li>可以后续处理：传递携带错误信息的失败的 promsie</li><li>也可以中断 Promise 链：返回一个 pending 状态的 promise，不再处理错误</li></ul></li><li>发请求时携带公共请求参数 token</li><li>返回响应 Response，不返回响应里的 data；再根据 code / status 判断请求成功还是失败 <ul><li>成功返回成功的数据</li><li>失败提示失败的准确原因</li></ul></li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>​ response.data.code：后台返回的 data 里的状态码</p><p>​ response.status： axios 本身响应结构自带的状态码，是来自服务器响应的 HTTP 响应状态码（1xx-5xx）</p><p>​ 功能上的错误：请求是成功的，响应是成功的，请求所做的事失败了；在响应拦截器的成功回调里判断后台返回的状态码去做；</p><p>​ 请求上的错误：请求可能是成功的也可能是一开始就失败的，请求的响应是失败的；在响应拦截器的失败回调判断 HTTP 响应状态码去做；</p><p>axios 响应结构：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 参考：https://www.axios-http.cn/docs/res_schema</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// \`data\` 由服务器提供的响应</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">data</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// \`status\` 来自服务器响应的 HTTP 状态码</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">status</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">200</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// \`statusText\` 来自服务器响应的 HTTP 状态信息</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">statusText</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">OK</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// \`headers\` 是服务器响应头</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 所有的 header 名称都是小写，而且可以使用方括号语法访问</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 例如: \`response.headers[&#39;content-type&#39;]\`</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">headers</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// \`config\` 是 \`axios\` 请求的配置信息</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">config</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// \`request\` 是生成此响应的请求</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 在 node.js 中它是最后一个 ClientRequest 实例 (in redirects)，</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 在浏览器中则是 XMLHttpRequest 实例</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">request</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div></div><h2 id="重要" tabindex="-1">重要 <a class="header-anchor" href="#重要" aria-label="Permalink to &quot;重要&quot;">​</a></h2><ol start="7"><li><p>取消重复请求：</p><p>意思：重复发两个相同的请求，取消上一次的请求，保留最新的请求</p><p>取消请求的流程：</p><ol><li>准备一个 map 对象</li><li>根据请求的 config 的内容生成一个唯一的 key</li><li>请求拦截器，从 map 对象找有没有 key， <ul><li>没有说明请求是第一次发，以 config 造出来的 key 为 key，以 cancle 为 value，添加到 map 当中去</li><li>有就证明发过请求，通过 key 拿到 cancle，调用取消发送请求，并把 map 中的 key 删除，就取消调上一次的请求了</li></ul></li><li>把最新的请求添加到 map 中</li><li>响应完成，不管是成功或失败了，响应拦截器的成功回调或失败回调里删除 key</li></ol><p>优化：加防抖防止多次发送相同请求</p></li><li><p>取消上一个页面的请求（主要靠全局前置导航守卫去做）</p><p>意思：当路由发生跳转，从上一个页面跳到新页面时，取消上一个页面的所有请求（因为没必要请求了）</p><p>取消上一个页面的请求建立在取消重复请求的基础之上（也就是说，前者包括了后者的功能）。只不过不仅仅保存取消请求的函数，还保存当前匹配的路由路径（还是以 config 造出来的 key 为 key，但是以 cancle 函数 和 window.loaction.path（当前路由路径） 构成的对象为 value）</p><p>流程：</p><ul><li>封装 axios 实现取消重复请求</li><li>守卫：删除上一个页面的请求，只要跳转，就判断请求列表中的请求地址和要去的路由地址是否时同一个，不相同就取消请求</li></ul></li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>2023-7-14 10:48:10</p></div>`,8),o=[e];function t(i,c,r,y,F,D){return a(),l("div",null,o)}const m=s(p,[["render",t]]);export{u as __pageData,m as default};
