import{_ as e,o as l,c as s,O as a}from"./chunks/framework.3d6e08ae.js";const h=JSON.parse('{"title":"keep-alive","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/JingJiang/Vue/源码/keep-alive源码.md","filePath":"Interview/JingJiang/Vue/源码/keep-alive源码.md"}'),n={name:"Interview/JingJiang/Vue/源码/keep-alive源码.md"},p=a(`<h1 id="keep-alive" tabindex="-1">keep-alive <a class="header-anchor" href="#keep-alive" aria-label="Permalink to &quot;keep-alive&quot;">​</a></h1><p>作用：keepalive 是一个内置的组件，这个组件可以缓存组件</p><p>传递的属性：</p><ul><li>include: 指定要缓存的是哪些组件</li><li>exclude: 指的是除了哪些组件，其余的都缓存</li><li>max: 最大缓存组件的个数</li></ul><p>过程：</p><ol><li><p>执行 created</p><ol><li><p>准备两个容器，一个对象，一个数组，对象当中后期存的就是我们缓存的组件对象，数组当中存的是缓存的组件对象的 key</p><ul><li><p>对象当中</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">cache </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;">)  </span><span style="color:#676E95;font-style:italic;">// {key1: 组件1, key2: 组件2}</span></span></code></pre></div></li><li><p>数组当中</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">keys </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [] </span><span style="color:#676E95;font-style:italic;">// [key2,key4,key5,key3,key1]  一旦key1对应的组件被重新挂载 =&gt; [key2, key1]</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 通过这个数组实现LRU2</span></span></code></pre></div></li></ul></li></ol></li><li><p>执行 render 函数创建虚拟 dom</p><ol><li><p>先通过 this.$slots.default（插槽：传给keep-alive缓存的组件实际上是传给了默认插槽）拿到缓存的组件，进而拿到组件的虚拟 dom 和 name</p></li><li><p>判断 include 和 exclude 是不是匹配我们拿到的 name</p><p>如果我们的那么 <strong>不在 include 或者在 exclude</strong> 当中，代表不缓存，直接返回拿到的虚拟 dom vnode（虚拟DOM节点）</p></li><li><p>先拿到之前 created 当中创建的两个容器，接下来拿 vnode 的 key，如果有就直接拿，没有去添加</p></li><li><p>用 key 去从 cache 当中看看有没有缓存过这个 vnode</p><p>如果有，直接从 vnode 去获取组件实例（组件实例存放在vnode的componentInstance属性上），组件实例不再从新创建，直接使用</p><pre><code>  LRU 的实现（保持要最新的要缓存的vnode的key永远处于数组的最右侧）

  1. 先从 keys 数组当中把存在的这个 vnode 的 key 删除
  2. 再从最右侧去 push 进去这个 keys 数组，保证最近使用的缓存的 vnode 的 key 永远处于数组的右侧
</code></pre><p>如果没有，在 this 身上把当前 vnode 和 key 暂存在两个属性 vnodeToCache 和 keyToCache</p></li><li><p>最后返回 vnode</p></li></ol></li><li><p>执行 mounted：专门调用函数去缓存组件 vnode</p><p>调用 this.cacheVNode()，缓存当前组件</p><p>并且去监视 include 和 exclude 的改变，动态删除不再缓存的组件</p><p>this.cacheVNode() 函数当中在真正去缓存没有缓存的组件</p><ol><li>判断有没有在 this.vnodeToCache 身上暂存 vnode</li><li>如果有，那么就构建要缓存的组件 vnode，进行真正的缓存</li><li>把暂存的 key，this.keyToCatch 添加到 keys 数组的最右侧</li><li>判断如果超过了缓存的最大数值，那么就调用 pruneCacheEntry(cache, keys[0], keys, this._vnode)，从 cache 当中把数组当中第一个 key 对应的组件 vnode 删除，还要从 keys 当中把第一个 key 给删除</li></ol></li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>prune /pruːn/ 修剪</p></div>`,7),o=[p];function i(t,c,d,r,y,k){return l(),s("div",null,o)}const u=e(n,[["render",i]]);export{h as __pageData,u as default};
