import{_ as i,o as l,c as e,U as a}from"./chunks/framework.e0394e94.js";const o="/interview/assets/强制缓存和协商缓存.62dff18b.jpeg",g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/JingJiang/fuwuduan/强制缓存和协商缓存.md","filePath":"Interview/JingJiang/fuwuduan/强制缓存和协商缓存.md","lastUpdated":1689411224000}'),t={name:"Interview/JingJiang/fuwuduan/强制缓存和协商缓存.md"},d=a('<h2 id="浏览器缓存机制-强制缓存和协商缓存" tabindex="-1">浏览器缓存机制：强制缓存和协商缓存 <a class="header-anchor" href="#浏览器缓存机制-强制缓存和协商缓存" aria-label="Permalink to &quot;浏览器缓存机制：强制缓存和协商缓存&quot;">​</a></h2><p>是什么：浏览器缓存是浏览器对请求过的文件进行缓存，以便下一次访问时重复使用</p><p>好处：提高访问速度，降低请求次数，可以减轻服务器压力</p><p>分类：浏览器缓存分为强制缓存和协商缓存。</p><p><img src="'+o+'" alt="强制缓存和协商缓存"></p><h3 id="强制缓存" tabindex="-1">强制缓存 <a class="header-anchor" href="#强制缓存" aria-label="Permalink to &quot;强制缓存&quot;">​</a></h3><p>浏览器不会向服务器发送请求，而是会直接从本地缓存中读取文件并返回响应状态码 200。</p><ul><li><code>200 OK (form memory cache)</code>：缓存来自内存</li><li><code>200 OK (form disk cache)</code>：缓存来自硬盘</li></ul><p>强制缓存是由服务器设置的，当服务器返回资源时，会携带特定的响应头字段： <code>Expires</code> 、 <code>Cache-Control</code> 。如果在缓存有效期内，下次请求该资源就会命中强制缓存，不会向服务器发送请求了。</p><ul><li><code>Expires</code>：Http 协议 1.0 的强制缓存方案。</li><li><code>Cache-Control</code>：Http 协议 1.1 的强制缓存方案（现在都用的 1.1）。</li></ul><p>如果这两个字段同时设置， <code>Cache-Control</code> 生效，它的权重更高。</p><p><strong>字段详情</strong></p><ol><li><p>Expires（超时时间）</p><p>它的值就是一个 GMT 格式的时间戳，比如： <code>Expires: Tue, 08 Mar 2033 01:20:16 GMT; </code></p></li><li><p>Cache-Control（控制强制缓存）</p><ul><li><p>max-age：用来设置资源缓存时间，单位为秒；</p></li><li><p>no-store：禁止一切缓存（这个才是响应不被缓存的意思）。</p></li><li><p>no-cache：强制客户端直接向服务器发送请求, 也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回 304，未变更。</p></li></ul></li></ol><h3 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h3><p>浏览器必须向服务器发送请求，由服务器判断该资源是否变化，从而决定是否走缓存。</p><ul><li>如果返回响应状态码 304，走缓存</li><li>如果返回响应状态码 200，不走缓存</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>304 Not Modified 说明无需再次传输请求的内容，也就是说可以使用缓存的内容。</p></div><p>协商缓存由：位于响应头的：<strong>Etag / Last-Modified</strong> 和位于请求头的 <strong>If-None-Match / If-Modified-Since</strong> 来决定。</p><p>大体流程如下：</p><ol><li>浏览器向服务器第一次请求资源，服务器返回该资源，响应状态码 200，在响应头设置 Etag 和 Last-Modified；</li><li>浏览器接受到资源时，会保存 Etag 和 Last-Modified 字段；</li><li>当浏览器刷新或重新请求资源时，会在请求头携带 If-None-Match（它的值就是之前保存的 Etag） 和 If-Modified-Since（它的值就是之前保存的 Last-Modified）两个字段发送给服务器: <ul><li>服务器会判断 If-None-Match 和 If-Modified-Since 与服务器保存的 Etag 和 Last-Modified 字段是否一致（判断是否是相同的文件）； <ul><li>如果一致，服务器返回响应状态码 304，浏览器接受到 304 状态码，就会自动去缓存中读取该资源；</li><li>如果不一致，服务器返回新的资源并携带新的 Etag 和 Last-Modified 字段给浏览器，此时响应状态码为 200。</li></ul></li></ul></li></ol><p><strong>字段详情</strong></p><p>Etag</p><ul><li>通常由文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行 Hash（算法，生成一个值，这个值等同于存放数据的地址） 后得到的。相同文件生成的 Etag 相同，不同文件生成的 Etag 不同；</li></ul><p>Last-Modified</p><ul><li>文件最近一次的修改时间</li></ul><h2 id="总流程" tabindex="-1">总流程 <a class="header-anchor" href="#总流程" aria-label="Permalink to &quot;总流程&quot;">​</a></h2><p>先看有没有强缓</p><ul><li><p>没有强缓，看有没有协缓</p></li><li><p>有强缓，看强缓有没有过期</p><ul><li>没过期，直接读强缓，返回缓存文件，响应状态码 200</li><li>过期，看有没有协缓 <ul><li>看有没有Etag（接没有强缓） <ul><li>有，发请求，携带If-None-Match</li><li>没有 <ul><li>看有没有Last-Modified <ul><li>有，发请求，携带If-Modified-Since <ul><li>由服务器决策，判断资源是否发生变化（接有Etag） <ul><li>没有变化，返回响应状态码 304，去缓存中读取该资源</li><li>变化了，响应状态码为 200，服务器返回新的资源并携带新的 Etag 和 Last-Modified 字段给浏览器</li></ul></li></ul></li><li>没有 <ul><li>向服务器发送新请求，服务器返回新的资源，响应状态码 200</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>',28),p=[d];function c(n,r,s,u,f,h){return l(),e("div",null,p)}const m=i(t,[["render",c]]);export{g as __pageData,m as default};
