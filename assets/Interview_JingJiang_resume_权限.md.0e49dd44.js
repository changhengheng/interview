import{_ as s,o as n,c as l,U as a}from"./chunks/framework.e0394e94.js";const u=JSON.parse('{"title":"权限","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/JingJiang/resume/权限.md","filePath":"Interview/JingJiang/resume/权限.md","lastUpdated":null}'),p={name:"Interview/JingJiang/resume/权限.md"},o=a(`<h1 id="权限" tabindex="-1">权限 <a class="header-anchor" href="#权限" aria-label="Permalink to &quot;权限&quot;">​</a></h1><p>权限控制：分前端控制和后端控制</p><h2 id="先说前端控制" tabindex="-1">先说前端控制： <a class="header-anchor" href="#先说前端控制" aria-label="Permalink to &quot;先说前端控制：&quot;">​</a></h2><p>菜单权限控制</p><ol><li>目的是让不同的用户登录后看到不同的菜单</li><li>菜单是遍历路由产生的，菜单不同，代表不同用户的路由不一样</li><li>路由是用户信息数据遍历产生的</li></ol><p>拆分路由（为什么）：不做权限控制的时候，所有的路由都放在一个路由数组里面，叫静态路由、常量路由，任何用户看到的路由就是一样的，想要做权限控制，就不能用一个路由去控制了，就需要拆分三大路由：</p><ul><li>静态路由：所有用户都能看到的路由</li><li>动态路由、异步路由：根据用户信息数据筛选出来的用户具有权限的路由</li><li>任意路由：404，必须放最后</li></ul><p>怎么做：</p><ul><li>登录后跳到全局前置守卫里获取用户信息（维护用户信息流程），获取到用户信息之后，从用户的权限信息数据中获取到自己的动态路由（异步路由）</li><li>通过 addRoute、addRoutes 将过滤出来的自己的异步路由动态的添加到路由器当中（做这一步只是实现了输入路径可以跳转，但组件还没办法显示，侧边栏也没办法显示）（因为路由数组还没有更新）</li><li>所以，最后还要把静态路由、用户自己的动态路由、任意路由合并到一个数组里面（实现菜单显示），让菜单展示时遍历这个数组</li></ul><p>权限数据管理</p><ul><li>有用户、角色、菜单：</li><li>多对多关系，一个用户可以有多个角色，角色可以分配给多个用户；角色有多个菜单，菜单分配给多个角色；</li><li>从属关系：角色只能设置给用户，菜单只能设置给角色；</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>后台返回的数据是角色、菜单、按钮</p></div><p>按钮权限控制：</p><p>自定义插件添加一个自定义指令 v-has，在每个按钮身上使用，值是每个按钮对应的权限信息数据，v-has 会判断这个值在不在用户返回的按钮权限信息数组里，如果在就显示，不再就不显示</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 自定义插件</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 插件分为对象式插件和函数式插件</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 对象式插件是一个对象</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 函数式插件是一个函数</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 对象式插件内部必须有一个方法叫 install</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 函数式插件，不需要有固定的名称，这个函数就是当做 install 去用</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 不管什么插件，本质都是在调用函数</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// v2 当中之前所写的 Vue.use(插件)，叫做声明使用插件，本质就是在调用插件的函数</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 对象式</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// {</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//   intall(){</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//   }</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 函数式</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// function xxx(Vue) {</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">hasBtnPermission</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">app</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">App</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 插件当中可以给 vue 添加任意你想添加的功能</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 自定义一个指令 v-has，指令名是不带 v - 的，用的时候要带 v-</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 指令名必须全小写</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// app.directive(&#39;has&#39;， (element， bindings) =&gt; {</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//   console.log(element);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//   // 谁用了 v-has，回调就会执行，一般接收两个参数</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//   // element 代表使用 v-has 的真实 dom 元素</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//   // bindings 代表绑定的数据组成的对象，想要拿到 v-has 后面的数据，bindings.value 去拿</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//   if (!useUserInfoStore().userInfo.buttons.includes(bindings.value)) {</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//     element.parentNode.removeChild(element)</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//   }</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// })</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 上面的写法会在 mounted 和 updated 都会执行，效率不高</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">directive</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">has</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">， </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        mounted</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">element</span><span style="color:#F07178;">， </span><span style="color:#A6ACCD;font-style:italic;">bindings</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">element</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 谁用了 v-has，回调就会执行，一般接收两个参数</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// element 代表使用 v-has 的真实 dom 元素</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// bindings 代表绑定的数据组成的对象，想要拿到 v-has 后面的数据，bindings.value 去拿</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#82AAFF;">useUserInfoStore</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">userInfo</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">buttons</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">includes</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">bindings</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">                </span><span style="color:#A6ACCD;">element</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">parentNode</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">removeChild</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">element</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">，</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h2 id="后端控制" tabindex="-1">后端控制 <a class="header-anchor" href="#后端控制" aria-label="Permalink to &quot;后端控制&quot;">​</a></h2><p>前台返回的用户信息数据是字符串数组，后台控制意思是说由后台返回动态路由</p><p>后台返回的是真真正正的路由数组，后期拆分路由只需要拆成两部分即可：静态和任意，动态由后端控制；</p><p>前台处理动态路由：需要递归遍历返回的动态路由生成懒加载的前台路由</p><p>动态添加路由：通过 addRoute、addRoutes 将生成的懒加载的异步路由、拆分的静态和任意路由动态的添加到路由器当中</p><h2 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h2><p>前台控制，路由是自己写在路由器里的；后台控制，动态路由是后台返回给前端的，缺点是返回的 component 的值是路由的地址，需要自己转化成懒加载的路由组件，变成真正的前端路由，最终才添加到路由器的；</p><p>区别：</p><ol><li>前台返回的是字符串数组，后台返回的是路由数组</li><li>前台拆分三大路由，后台拆分两大路由</li></ol><p>后台控制更好一点</p><hr><h2 id="路由权限控制" tabindex="-1">路由权限控制 <a class="header-anchor" href="#路由权限控制" aria-label="Permalink to &quot;路由权限控制&quot;">​</a></h2><p>bug1：模板项目自身代码的问题</p><ul><li><p>描述: 在权限路由上刷新 / 登陆成功后跳转到权限路由， 页面是空白的，进不了 404</p></li><li><p>原因: 在请求获取用户信息 (包含路由权限) 后， 自动动态添加了权限路由；我们是无条件放行 next()；但由于这个操作发生在一次路由跳转的过程中， 这次的路由跳转是看不到新添加的路由；只有再次跳转一下（next(to)），才能看到最新添加的异步路由；</p></li><li><p>解决:</p></li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// next() // 放行， 没有重新跳转， 看不到最新添加的动态路由</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// next(to.path) // 重新跳转到目标路由， 但丢失了参数 (如果有的话)</span></span>
<span class="line"><span style="color:#82AAFF;">next</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">to</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// 重新跳转到目标路由， 且参数不会丢失</span></span>
<span class="line"><span style="color:#A6ACCD;">NProgress</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">done</span><span style="color:#A6ACCD;">() </span><span style="color:#676E95;font-style:italic;">// 结束进度条</span></span></code></pre></div><p>bug2: 我们代码的问题</p><ul><li>描述: 如果先用一个 A 用户登陆， 退出后用 B 用户登陆， 结果看到与 A 用户相同部分的菜单是</li><li>原因: 我们在过滤总的异步路由数组中， 过滤掉了内部部分子路由， 另一个用户登陆看不到总的路由数组了</li><li>解决: 深拷贝然后再进行过滤 ==&gt; 不去改变总的异步路由数组</li></ul><h2 id="按钮权限控制" tabindex="-1">按钮权限控制 <a class="header-anchor" href="#按钮权限控制" aria-label="Permalink to &quot;按钮权限控制&quot;">​</a></h2><ul><li>是什么效果? 有权限的按钮才显示</li><li>需要进行权限控制的按钮都对应一个唯一的标识名称: btn. User.add</li><li>实现: <ul><li>获取用户信息时得到了所有的按钮权限名称的数组 [&#39;btn. Attr.add&#39;， &#39;btn. Attr.remove&#39;]</li><li>定义一个用于判断当前用户是否有指定按钮权限的函数 ==&gt; 将其绑定到 Vue 的原型上， 让所有组件都可以直接使用</li><li>在组件的模板中， 使用 v-if + 按钮权限判断函数来判断是否显示某个按钮</li></ul></li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>路由（菜单）权限的控制</p><ul><li>全局路由导航守卫 和 动态添加路由 才能做路由菜单权限控制 <ol><li>用户登录</li><li>全局路由导航守卫当中获取用户的菜单权限数据信息（name 数组 routes）</li><li>根据用户的菜单权限数据信息，从所有的异步路由当中过滤出当前用户自己的异步路由</li><li>使用路由器的动态添加路由，将用户的异步路由和任意路由，动态添加到路由器当中</li><li>菜单是根据，当前用户的所有路由，动态生成</li></ol></li></ul>`,37),e=[o];function t(i,c,r,y,F,D){return n(),l("div",null,e)}const A=s(p,[["render",t]]);export{u as __pageData,A as default};
