import{_ as s,o as l,c as a,U as n}from"./chunks/framework.e0394e94.js";const k=JSON.parse('{"title":"nextTick","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/JingJiang/Vue/源码/nextTick源码.md","filePath":"Interview/JingJiang/Vue/源码/nextTick源码.md","lastUpdated":1689411224000}'),e={name:"Interview/JingJiang/Vue/源码/nextTick源码.md"},t=n(`<h1 id="nexttick" tabindex="-1">nextTick <a class="header-anchor" href="#nexttick" aria-label="Permalink to &quot;nextTick&quot;">​</a></h1><p>作用：等待页面最近一次更新完成，执行传递的回调</p><p>场景：数据更新，引起页面更新，此时我们需要获取真实 dom 去操作</p><p>数据更新是同步的，页面更新是异步，导致获取到的真实 dom 是 undefined 如果我们需要操作，就得把自己的操作放在 nextTick 传递的回调当中</p><p>本质：nextTick 其实最终本质是把我们自己的操作，变为异步</p><h2 id="一、nexttick-的用法" tabindex="-1">一、nextTick 的用法 <a class="header-anchor" href="#一、nexttick-的用法" aria-label="Permalink to &quot;一、nextTick 的用法&quot;">​</a></h2><p>nextTick() 函数调用：</p><ol><li>传递我们自己的回调</li><li>也可以是直接调用（不传参），返回 promise，在 promise 的. then 当中传递我们自己的回调</li></ol><h2 id="二、nexttick-的执行过程" tabindex="-1">二、nextTick 的执行过程 <a class="header-anchor" href="#二、nexttick-的执行过程" aria-label="Permalink to &quot;二、nextTick 的执行过程&quot;">​</a></h2><ol><li><p>定义一个数组 <strong>callbacks</strong> ，这个数组以后存储的都是函数</p></li><li><p>定义一个 <strong>flushCallbacks</strong> 函数，拷贝 callbacks 进行遍历，调用其中的每一个函数</p></li><li><p>定义 **timerFunc ** 函数，定义的时候是根据环境去判断，（写了四个判断）不同的环境定义不同的 timerFunc 函数</p><p>作用：定义 timerFunc 函数，是想把 flushCallbacks 放到异步队列当中</p><ol><li><p>先判断是否支持 promise</p><p>如果支持，定义 timerFunc 函数内部会把 flushCallbacks 当做 promise 成功的回调，放到微队列</p></li><li><p>如果不支持 promise，那么再去判断是否支持 <strong>MutationObserver</strong></p><p>如果支持，那么就手动创建 dom 节点，去实例化 MutationObserver，传递 flushCallbacks 函数，通过实例化的对象去监视 dom 节点变化，如果 dom 节点发生变化，就会把传递的 flushCallbacks 放入微队列。定义 timerFunc 函数，内部只需要修改节点即可</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>MutationObserver 构造函数</p><p>作用：用来监听页面 DOM 元素的变化，执行其中的回调</p><p>用法：</p><ol><li><p>实例化调用 MutationObserver ，传入一个回调，回调有两个默认参数</p></li><li><p>通过 observe 方法确定监听的 DOM 元素，并配置 MutationObserver 的回调接收 DOM 元素变化的信息通知</p><p>配置：</p><ul><li>characterData：监听声明的 target 节点上所有字符的变化</li><li>textNode.data = String(counter) 手动更新 DOM</li></ul></li></ol></div><p>上面的两种都是微任务，下面的两种都是宏任务，timerFunc 在定义让 flushCallbacks 为异步的时候，微任务优先级高于宏任务</p></li><li><p>如果前面两种都不支持，那么再去看宏任务，先去判断是否支持 <strong>setImmediate</strong>，是在 node 环境下用，如果支持就调用 setImmediate, 把 flushCallbacks 传递当做参数，最终就会把 flushCallbacks 放到宏队列当中</p></li><li><p>如果上面都不支持，无论浏览器环境是什么，setTimeout 都是支持的，此时就会调用 setTimeout，把 flushCallbacks 放到宏队列</p></li></ol></li><li><p>定义 nextTick 函数</p><ol><li>传递回调函数用法 <ol><li>新定义一个函数，判断是否传递了 <strong>cb</strong> 回调，如果传递了 cb 回调，就去执行 cb 回调，把这个定义的函数，push 到 callBacks 当中</li><li>调用 timerFuc, 真正的把 flashCallbacks 放到异步队列当中，后期执行线程执行完同步代码，就会去异步队列当中 拿到 flushCallbacks 去执行，flushCallbacks 又是在遍历 callBacks 数组中的函数，就会挨个执行</li></ol></li><li>没有传递回调函数，Promise 的用法 <ol><li>新定义一个函数，函数内部是判断是否传递了 cb 回调，如果没有传递了 cb 回调，就去执行**_resolve()** 把这个定义的函数，push 到 callBacks 当中</li><li>调用 timerFuc, 真正的把 flashCallbacks 放到异步队列当中</li><li>判断 cb 没有传递并且 promise 支持，就返回一个 pending 状态 promise 的同时，把执行器函数当中 resolve，赋值给 _resolve，后期在执行上一步的 _resolve 的时候, 就会把返回的 pending 状态改为成功状态</li></ol></li></ol></li></ol><h2 id="拓展" tabindex="-1">拓展 <a class="header-anchor" href="#拓展" aria-label="Permalink to &quot;拓展&quot;">​</a></h2><p>数据更新是同步的，页面更新是异步的</p><p>现在我们使用 nextTick 让自己操作 dom 的任务也是异步了，凭什么自己操作的这个异步任务就会在页面更新的异步任务后面执行呢？</p><p>页面更新是异步的，源码当中页面的更新操作，也是使用 nextTick 去在队列排队</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">input</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">ref</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">inputRef</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">v-if</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">inputShow</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">handleInput</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">inputShow</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 这个数据更新，导致页面会更新，页面更新的操作会通过 nextTick 去做异步处理，放到异步队列去执行</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 我们接下来写的 nextTick，也会把我们自己的回调最终放到异步队列当中去执行</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 都是通过 nextTick 去放队列，就有了先来后到</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 因此修改数据的代码不能放在自己写的 nextTick 后面去</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">nextTick</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  	</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">$refs</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">inputRef</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">focus</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div>`,15),p=[t];function o(c,i,r,F,u,D){return l(),a("div",null,p)}const h=s(e,[["render",o]]);export{k as __pageData,h as default};
