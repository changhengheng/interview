import{_ as e,o as t,c as i,O as a}from"./chunks/framework.3d6e08ae.js";const m=JSON.parse('{"title":"Vue3 响应式数据原理 **************************","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/JingJiang/Vue/源码/Vue3响应式数据原理.md","filePath":"Interview/JingJiang/Vue/源码/Vue3响应式数据原理.md"}'),p={name:"Interview/JingJiang/Vue/源码/Vue3响应式数据原理.md"},l=a('<h1 id="vue3-响应式数据原理" tabindex="-1">Vue3 响应式数据原理 ************************** <a class="header-anchor" href="#vue3-响应式数据原理" aria-label="Permalink to &quot;Vue3 响应式数据原理 **************************&quot;">​</a></h1><p>vue2 通过 Object.defineProperty 做的，不能监视属性的新增和删除 所以有 $set 和 $delete</p><p>vue3 通过 proxy 和 reflect 去实现</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>proxy 拦截操作 reflect 操作数据</p></div><ul><li><p>创建代理对象，可以对代理对象的增删改查全部进行监视捕捉, 因此 vue3 废弃了 $set 和 $delete</p></li><li><p>当用户访问代理对象的属性时，触发 get 捕捉器，在捕捉器当中会通过反射返回源对象的值，同时进行依赖收集</p></li><li><p>vue2 收集的依赖是 watcher, 它里面收集的是 effect 函数</p></li><li><p>当用户设置代理对象的属性时，触发 set 捕捉器，在捕捉器当中通过反射设置源对象的属性值，同时候派发更新页面</p></li><li><p>利用 map 和 set 去，找到 dep 的 set，让 dep 去遍历所有的 effect 去执行修改页面</p></li></ul>',5),r=[l];function s(_,c,o,n,u,d){return t(),i("div",null,r)}const v=e(p,[["render",s]]);export{m as __pageData,v as default};
