import{_ as i,o as e,c as t,U as a}from"./chunks/framework.e0394e94.js";const f=JSON.parse('{"title":"执行上下文","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/JingJiang/JavaScript/执行上下文.md","filePath":"Interview/JingJiang/JavaScript/执行上下文.md","lastUpdated":1689495355000}'),l={name:"Interview/JingJiang/JavaScript/执行上下文.md"},n=a('<h1 id="执行上下文" tabindex="-1">执行上下文 <a class="header-anchor" href="#执行上下文" aria-label="Permalink to &quot;执行上下文&quot;">​</a></h1><ul><li><p>js引擎在解析每段代码之前要做一些准备工作（开辟一块内存空间，创建变量对象，作用域链，确定this指向），这个准备工作被称作为执行上下文。</p></li><li><p>执行上下文全称叫执行上下文环境，它是程序在运行过程当中必须要依赖的环境。</p></li><li><p>分类：全局执行上下文 函数执行上下文</p></li><li><p>无论是什么执行上下文都分为两个阶段：创建阶段（程序或者函数执行了，但是代码还没走：在创建执行环境）和执行阶段（代码开始走）</p><ul><li><p>创建阶段主要干三件事 0. (0、开辟一片内存空间，创建全局执行上下文环境压入栈中)</p><ol><li>收集变量形成变量对象（此过程当中就包含了预解析，达到的效果是变量提升）（变量对象是存在堆里的，window的变量- 对象叫global（是个变量，指向堆里的变量对象，其实就是window对象，只不过不叫window，叫global），执行上下文是在栈里的）（预解析：变量声明提升（undefined），函数声明整体提升（直接创建好函数了放在堆里，不是undefined））（函数在定义的时候就确定了函数调用时的上级作用域）（函数定义和函数调用）</li><li>确定此执行上下文当中的this指向（this是当前执行上下文的内置变量，程序执行的时候确定的，但代码还没走）</li><li>确定此执行上下文当中的作用域链（变量对象组成的数组） （只有全局作用域和函数作用域才有执行上下文，才有this，才有作用域链）</li></ol></li><li><p>执行阶段：主要就是找到变量进行赋值或者找到变量并使用变量的值</p></li><li><p>注意：函数执行上下文创建阶段第一步，额外多做了一件事，先去传递参数，形成arguments，再去收集变量形成变量对象（预解析）</p></li></ul></li><li><p>每执行一段代码就会创建对应的执行上下文，程序中可能会创建多个执行上下文。每次执行js的时候，都会在内存中创建一个执行上下文栈，用来存放执行上下文。js最开始执行的时候，先创建了全局执行上下文，并压入栈中，当页面关闭的时候，把它从栈中弹出。当进入函数的时候，会把局部执行上下文压入栈中，当函数执行完毕后弹出。</p></li></ul>',2),o=[n];function s(_,p,r,d,c,h){return e(),t("div",null,o)}const m=i(l,[["render",s]]);export{f as __pageData,m as default};
