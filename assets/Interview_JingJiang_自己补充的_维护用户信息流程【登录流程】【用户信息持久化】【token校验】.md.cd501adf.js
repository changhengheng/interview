import{_ as n,o as e,c as t,U as o}from"./chunks/framework.e0394e94.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/JingJiang/自己补充的/维护用户信息流程【登录流程】【用户信息持久化】【token校验】.md","filePath":"Interview/JingJiang/自己补充的/维护用户信息流程【登录流程】【用户信息持久化】【token校验】.md","lastUpdated":null}'),l={name:"Interview/JingJiang/自己补充的/维护用户信息流程【登录流程】【用户信息持久化】【token校验】.md"},r=o(`<p>userTempId：</p><ul><li>用来区分不同的用户，作为未登录用户的临时身份标识，记录用户的一些数据，比如说添加到购物车的商品</li></ul><p>代码逻辑：</p><ul><li>前提：用户没有登录</li><li>使用uuid生成userTempId</li><li>存储到localStorage（封装一个生成userTempId的方法--&gt;代码逻辑--&gt;- localStorage获取，判断，如果有，就返回。没有就新生成一个，存到localStorage中，再返回。）</li><li>发请求时在请求拦截器里携带到请求头里，添加时和后台商量好</li></ul><p>注册就是一般的流程：</p><ul><li>收集数据</li><li>整理数据</li><li>写API</li><li>发请求</li><li>成功和失败提示</li></ul><p>登录：</p><pre><code>token：

- 是用户登陆成功（维持登录状态）的唯一标识。登录成功时，服务器（才）会为该用户生成一个token。
- token是用户真正身份的唯一标识（区别于用户的临时身份标识userTempId），根据token，可以去服务器那查询到该用户的所有信息。
- 一般存储在localStorage，为了做自动登录
- 单点登录和多端登录：
    - 单点登录：服务器要在用户登录后，把之前的\`token\`销毁，再生成一个新的\`token\`。
    - 多端登录：每次返回同一个token
- token的销毁：
    - 到了过期时间，服务器就自动销毁该\`token\`了，过期时间是由后台设置的。
    - 若用户主动退出登录，那么服务器就会销毁该用户的\`token\`。
token的代码逻辑：

- 用户登录成功后拿到token，存到localStorage里（一般维护到vuex/pinia里，因为很多组件都会都用到）（为了方便，可以将对token的操作: 读、写、删除，封装成函数）
- 发请求时在请求拦截器里，把token携带在请求头里（先从vuex获取，判断，有就携带）
token和临时标识都需要携带——为了合并用户数据（面试题），两个标识都存在的话，后台会合并临时id对应的信息到token对应的信息上 token是老大

只有登录接口不需要携带token，因为登录要么会拿到已有的token，要么会生成一个全新的token
</code></pre><p>用户信息：</p><pre><code>获取用户信息：

    - 也是一般的流程，需要注意在请求头携带token
    - 保存在vuex/pinia，可以尽量保证用户信息是最新的
    - 为什么不能放localStora？可以实现，但不是很好，因为存的一点意义都没有，刷新页面、重开浏览器后，我们不确定信息还是否有效，还得通过 token 请求最新的用户信息。
    - 其他有bug的存储方式：
        - App 组件中\`dispatch(&#39;getUserInfo&#39;)\`。不行，会有严重bug，在初次登录的时候，无法获取用户信息，因为App页面只挂载一次，而这一次请求头里是没有token的。
        - 在各个组件中\`dispatch(&#39;getUserInfo&#39;)\`。可以实现，但不是很好，如果组件很多的话，太麻烦了！
维护用户信息【用户信息持久化】

- vuex/pinia里存放的数据的缺点在于刷新页面、关闭浏览器就会丢失，因此需要做持久化
- 用户信息持久化使用全局路由前置守卫完成
全局前置导航守卫（token校验代码逻辑）：

- 首先获取到用户的token和userInfo
</code></pre><ul><li><p>判断用户的token是否存在 如果token存在，代表用户之前登录过，判断用户目前是不是又去登录页面 如果用户去的又是登录页面，那么强制跳转到首页 如果用户去的不是登录页面，那么接着要判断用户信息是否在存在 如果用户的信息是存在的，代表用户已经根据token获取到了信息，无条件放行 如果用户的信息不存在，我们就得去发请求获取用户的信息 如果获取用户信息成功，无条件放行 如果获取用户信息失败，代表token过期，清空当前token，跳转到登录页面重新登录获取token</p><pre><code>如果token不存在， 证明用户没有登录过，那就意为着：根本就不用发请求获取用户信息。没登录的话，有些敏感路由是不能去的，比如：交易路由、支付路由、我的订单路由。需要做权限控制（看路由鉴权）。
</code></pre></li></ul><p>响应拦截器处理token过期：</p><pre><code>用户登录后一直使用系统，不刷新页面，用了好久好久，达到了 \`token\` 的过期时间，这时所有需要身份信息的请求，都不会有正确的响应（服务器 \`code\` 为 \`208\` ），此时应该触发：退出登录逻辑。
</code></pre><p>退出登录</p><pre><code>需要做四件事：

- 发请求，通知服务器销毁\`token\`。
- 清空\`localStorage\`中的\`token\`。
- 清空\`vuex\`中用户的信息。
- 跳转到\`/login\`路由。
</code></pre><p>路由鉴权：</p><pre><code>目的是组织非法访问没有权限的路由，只要不往具体的路由路径跳转即可。实现可以用一个数组，然后遍历，只要是其中的就都重定向（next）到首页。

基本鉴权
    有些路由只有登录了，才能看；—— 使用&lt;strong style=&quot;color:red&quot;&gt;全局守卫&lt;/strong&gt;去做。
细化鉴权
    只有在特定路由，才能去特定路由。
    使用【路由独享守卫】细化鉴权规则，配置写在路由规则中（ \`src/router/routes.js\` ）。
    使用【组件内守卫】细化鉴权规则，配置写在组件中（ \`.vue\` 文件）
</code></pre><p>自动登录：</p><pre><code>1、store内部token初始化的时候要从localStorage里面获取
2、请求成功后不但要在store里保存token，而且要在localStorage里面保存
3、用户信息获取失败，清空token的时候不但要清空state里面的token而且要清空localStorage当中token
</code></pre><hr><p>其他：</p><p>路由导航守卫的概念（参考官网去写代码）</p><pre><code>当路由跳转的时候，这个守卫可以去拦住，检测你是否有去往这个页面的条件
有特定条件才能去到相应的页面的功能

拦截路由，查看是否满足条件，满足的放行，不满足的处理

全局导航守卫： 
	无论是从哪个页面往哪个页面跳转，只要有路由跳转，就会拦住，进行检测
	
	前置守卫   配置的比较靠前       匹配路由前拦截，用的最多      *************** 
	解析守卫   配置的位置中间       匹配路由中拦截，用的比较少
	后置守卫   配置的比较靠后       匹配路由完成拦截，用的比较少

路由独享守卫：

	只能去拦住固定的往某个页面跳转的，是配置在当前路由当中，只要是匹配当前路由就会拦截检测
	不是当前路由不管    只有一个
	

组件内守卫：	
	只能去拦住固定的往某个页面跳转的，是配置在组件内部，也就是路由匹配已经完成了，时间比较靠后

	就是解析完了，已经跳转到组件的时候，但是组件还没创建成功的时候拦截
</code></pre>`,23),p=[r];function i(a,_,c,k,d,s){return e(),t("div",null,p)}const S=n(l,[["render",i]]);export{g as __pageData,S as default};
