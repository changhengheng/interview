import{_ as e,o as i,c as t,U as l}from"./chunks/framework.e0394e94.js";const g=JSON.parse('{"title":"Vite 和 WebPack 的区别","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/JingJiang/gongchenghua/Vite和WebPack的区别.md","filePath":"Interview/JingJiang/gongchenghua/Vite和WebPack的区别.md","lastUpdated":null}'),a={name:"Interview/JingJiang/gongchenghua/Vite和WebPack的区别.md"},o=l('<h1 id="vite-和-webpack-的区别" tabindex="-1">Vite 和 WebPack 的区别 <a class="header-anchor" href="#vite-和-webpack-的区别" aria-label="Permalink to &quot;Vite 和 WebPack 的区别&quot;">​</a></h1><ol><li>底层语言不同</li></ol><p>从底层原理上来说，Vite 是使用 rollup 打包，基于 esbuild 进行依赖预构建（将第三方依赖进行打包，并在开发环境下使用这些打包过的依赖），进行缓存。而 esbuild 是采用 go 语言编写，因为 go 语言的操作是纳秒级别。而 js 是以毫秒计数，所以 vite 比用 js 编写的打包器快 10-100 倍。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>esbuild 是一个 js 打包器</li><li>webpack 是 node 写的（node 是 c++ 写的）</li></ul></div><ol start="2"><li>启动方式不同</li></ol><p>webpack: 分析依赖 =&gt; 编译打包 =&gt; 交给本地服务器进行渲染。首先分析各个模块之间的依赖，然后进行打包。这样的坏处就是随着模块的增多，需要处理的依赖关系，需要打包的模块越来越多，造成热更新越来越慢</p><p>vite: 启动服务器 =&gt; 请求模块时按需进行动态编译显示。vite 采用了一种懒加载的方式，它在启动的时候不需要打包，所以不用分析模块与模块之间的依赖关系，不用进行编译；当浏览器请求某个模块时，再根据需要对模块内容进行编译，这样做的好处就是按需动态编译可以缩减编译时间，当项目越复杂，模块越多的情况下，vite 明显优于 webpack.</p><ol start="3"><li>缺点比较</li></ol><ul><li>vite 生态不及 webpack，加载器、插件不够丰富</li><li>打包到生产环境时，vite 使用传统的 rollup 进行打包，生产环境 esbuild 构建对于 css 和代码分割不够友好。所以，vite 的优势是体现在开发阶段</li><li>vite 首屏性能不及 webpack <ul><li>Webpack：浏览器发起请求，服务端将已经打包构建好的首屏内容发送给浏览器。整个过程非常普遍，没有什么可说的，不存在什么性能问题</li><li>Vite 在首屏方面的表现就有些差了。由于 unbundle 机制，首屏期间需要额外做以下工作: <ul><li>不对源文件做合并捆绑操作，导致大量的 http 请求；</li><li>dev server 运行期间对源文件做 resolve、load、transform、parse 操作；</li><li>预构建、二次预构建操作也会阻塞首屏请求，直到预构建完成为止</li></ul></li></ul></li></ul>',9),c=[o];function s(n,r,p,_,d,u){return i(),t("div",null,c)}const k=e(a,[["render",s]]);export{g as __pageData,k as default};
